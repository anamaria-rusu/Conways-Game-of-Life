# Conway's Game of Life in Assembly - x86

## Description  
This project implements **Conway's Game of Life** using **AT&T x86 Assembly**. Additionally, it features an encryption method based on **k-evolutions of the game**, which transforms the game states into a **bitstream** to create an encryption system. By applying the game rules to an extended matrix **Sₖ**, a **cryptographic key** can be generated for message encryption and decryption.

## Key Features  
- Development of **Conway's Game of Life** in **Assembly**, simulating the evolution of cells in a two-dimensional matrix based on simple rules.  
  
  Rules:
  - **Underpopulation**: A live cell with fewer than two live neighbors dies in the next generation.
  - **Survival**: A live cell with two or three live neighbors survives.
  - **Overpopulation**: A live cell with more than three live neighbors dies.
  - **Birth**: A dead cell with exactly three live neighbors becomes alive.
  - **Stasis**: Any dead cell not meeting the birth condition remains dead.

- **Encryption based on game evolutions** – Defining an encryption key starting from an initial configuration **S₀** and applying a **k-evolution** to produce a bitstream. Message **m** encryption is performed via XOR between the message and the key generated by the game.

- **Virtualization and Debugging** – Use of **Oracle VM VirtualBox** to create an isolated development environment and **Linux** for debugging. **GDB** is used for analyzing register states and execution flow.

## Technologies and Concepts Used  
- **Programming Language:** Assembly (AT&T x86)  
- **Encryption:** XOR, using game evolutions to generate cryptographic keys  
- **Virtualization:** Oracle VM VirtualBox  

## Project Structure  
1. **Game of Life code** – Implementation of the cell state update algorithm and their evolution according to the rules.  
2. **Key generation** – Application of k-evolutions to obtain a bitstream used for message encryption and decryption.  
